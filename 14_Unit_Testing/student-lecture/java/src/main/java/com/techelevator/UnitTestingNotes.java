package com.techelevator;

public class UnitTestingNotes
{
	/*Unit Testing
	 * 
	 * SDLC --> Software Development Life Cycle
	 *
	 * Requirements --> 
	 * 		What the needs are, look at current code, look at what their processes are, 
	 * 		ask questions, ask questions, ask questions... you can never ask too many questions in this step
	 * 		Who, What, Why, When, How. 
	 * Design -->
	 * 		Class Diagram, Process Flow, UML (Unified Modeling Language, way to communicate between tech and client), 
	 * 		
	 * Code -->
	 * 		write the code
	 * Test -->
	 * 		QA team (gets paid to break your code), Automated Testing, 
	 * Deploy -->
	 * 		Cloud, aws, Azure, Apple Store, Google Play Store, servers, pushing live
	 * 
	 * 
	 * Approaches to Testing
	 * 	- Manual Testing
	 * 		- slower
	 * 		- can be customized 
	 * 		- Exploratory Testing
	 * 			- explore and find potential problems
	 * 			- write tests around this
	 * 		- Component Testing 
	 * 			- Customizable, swap out parts, losely coupled 
	 * 		- Integrated Testing
	 * 			- Tightly coupled, not as flexible
	 * 
	 *  - Automated Testing
	 *  	- faster
	 *  	- controls in place to make sure any error doesn't happen again
	 *  	- very specific 
	 * 
	 *  - Unit Testing 
	 *  	- testing each component individually
	 *  	- most of our time using this method
	 *  - Integration Testing
	 *  	- I know which specific components I want, how do they fit together?
	 *  	- test to ensure all pieces work together before we put it all together
	 *  	- Interfaces allow each of these to be put together
	 *  - UI Testing --> User Interface Testing --> Manual
	 *  	- good user experience
	 *  	- works as user expects it to
	 *  - End to End Testing
	 *  	- testing from start to finish
	 *  	- 
	 * 
	 * Testing Pyramid 
	 * 
	 * 			E2E - 
	 * 
	 * 		Integration - set up each component b4 tests
	 * 
	 * 	Unit Testing - runs fast, millions of tests possible. 
	 * 
	 * 
	 * 
	 */

}
